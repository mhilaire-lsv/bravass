
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\bibliographystyle{plainurl}% the mandatory bibstyle
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{mathtools}
\usepackage{todonotes}
\usepackage{microtype}

\usepackage{complexity}
\usepackage{amsmath}
\usepackage{dsfont}

\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{graphicx}




\newcommand{\problemx}[3]{
	\vspace{0.2cm}
\par\noindent\underline{\sc#1}\par\nobreak\vskip.2\baselineskip
\begingroup\clubpenalty10000\widowpenalty10000
\setbox0\hbox{\bf INPUT:\ }\setbox1\hbox{\bf QUESTION:\ }
\dimen0=\wd0\ifnum\wd1>\dimen0\dimen0=\wd1\fi
\vskip-\parskip\noindent
\hbox to\dimen0{\box0\hfil}\hangindent\dimen0\hangafter1\ignorespaces#2\par
\vskip-\parskip\noindent
\hbox to\dimen0{\box1\hfil}\hangindent\dimen0\hangafter1\ignorespaces#3\par
\endgroup
	\vspace{-0.2cm}
}

\newcounter{claimcounter}
\setcounter{claimcounter}{0}
\newtheorem{subclaim}{Subclaim}{}
\newtheorem*{theorem*}{Theorem}

\makeatletter

\usepackage{ textcomp } 

\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{graphicx}

\usepackage{wrapfig}



\renewcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\T}{\mathcal{T}}
\renewcommand{\G}{\mathcal{G}}
\renewcommand{\O}{\mathcal{O}}
\renewcommand{\R}{\mathbb{R}}
\renewcommand{\H}{\mathcal{H}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Time}{\mathbb{T}}
\newcommand{\Const}{\mathsf{Consts}}
\newcommand{\Conf}{\mathsf{Conf}}
\newcommand{\PTA}{\textsc{PTA}}
\newcommand{\MSO}{\textsc{MSO}}


\renewcommand{\poly}{\mathrm{poly}}

\newcommand{\Op}{\mathsf{Op}}
\newcommand{\win}{\textsc{Win}}



\newcommand{\semi}[1]{\xRightarrow{'1}}




\title{Parity games in pushdown systems with parameters} 

\titlerunning{Parity games in pushdown systems with parameters} 

\author{Mathieu Hilaire}{Université Paris-Saclay,
CNRS,
ENS Paris-Saclay,
LMF,
Gif-sur-Yvette, France
}{hilaire@lsv.fr}{}{This work was partly done while the author was supported by the 
Agence Nationale de la Recherche grant no.  ANR-17-CE40-0010.}

\authorrunning{M. Hilaire} 

\Copyright{M. Hilaire} 

%\ccsdesc[500]{Theory of computation~Timed and hybrid models}
%\ccsdesc{Theory of computation~Automata over infinite objects}
\ccsdesc[500]{Theory of computation~Automata extensions}

\keywords{Parity Games, Computational Complexity, Pushdown systems}



\category{} 

\relatedversion{}
% \relatedversiondetails{Full Version}{}

\acknowledgements{The author would like to thank Benedikt Bollig, Stefan G\"oller and Alain Finkel for helpful discussions and feedback. The author would also like to thank the anonymous reviewers from FSTTCS 2022 for their helpful suggestions and remarks.}


\ArticleNo{70}
\begin{document}

\maketitle


\begin{abstract}
	We investigate the decidability and complexity of
	parity games over an extension of pushdown systems.
	More specifically, we consider parametric pushdown systems, in
	which parameters can be instantiated to some word over a stack alphabet,
	and compared against the current stack content.
	We determine the problem
	belongs to $(n+1)$-$\EXP$ in case the number of parameters
$n$ is fixed, and provide a nonelementary lower bound for the general case. 
\end{abstract}

\section{Introduction}


{\bf Background.} Pushdown systems can be used to model the behavior of recursive programs.
They have applications for instance in inter-procedural control-flow analysis of recursive programs \cite{esparza1999automata, reps2005weighted}.
More generally, a variety of 
 program analysis questions can be reduced to decision problems for games on pushdown systems.




In particular, two player games can be used to
 represent the
interaction of a program with some environment, with the first player representing the program while the second player represents the environment. A winning condition then expresses a property required to hold however the environment behaves. Finding a winning strategy for the first player
thus provides some way 
 to ensure the desired 
property~\cite{arnold2003games}.
It is known from \cite{walukiewicz1996pushdown} that deciding the winner of a parity game on a graph of a pushdown system is an ${\sf EXPTIME}$-complete problem.


{\bf Parametric constraints.}
For certain types of computer programs, such as embedded systems, it can
be necessary to consider under-specified constraints rather than concrete specifications only.
Unspecified values represented by parameters have been used
for instance in parametric timed automata~\cite{AHV93-stoc} and parametric one-counter automata~\cite{haase2012complexity, lechner2015complexity} in which
verification of the desired properties of the system is then performed without concrete values.
 We consider in this article a similar approach, only applied to pushdown systems. Rather than comparing a counter against a parametric number, we allow comparison of a stack content against a parametric word.
  Perhaps a similar model consists in  pushdown systems with transitions that are conditioned by regular conditions on their stack content, which can in particular test the stack content against specific words. 
They can be used to ensure that some word over the stack alphabet appears in the configurations of a run, but only for a specific value (or, rather, specific regular languages).
They have  been used to  obtain  algorithms for LTL and CTL$^*$ model checking
for pushdown systems~\cite{finkel1997direct}.
Instead of checking the stack content against regular conditions, or against specified word values, we consider checks against unspecified word values, instantiated using parameters, and compared against using parametric guards.
This allows for example to ensure equality between two stack contents appearing in two distincts configurations in a run.



{\bf Related models.}
Recently, different variants of parametric pushdown systems have been introduced in the literature 
\cite{hague2011parameterised, esparza2016parameterized, fortin2017model} 
however as
parameterized asynchronous shared-memory systems.
These consist of a leader pushdown system
and arbitrarily many identical contributor pushdown systems, communicating via a shared memory
in the form of a register which can take finitely many values.
They have applications
in the dataflow analysis of concurrent programs~\cite{kahlon2008parameterization}. 
This article's approach to extending pushdown systems with parameters is different in that it makes them appear directly in equality tests against the stack.

Extensions of pushdown systems with storage for later comparisons
have been introduced for instance as register pushdown systems. 
Such automata possess registers in addition to their stack, and can keep data values in both.
Register pushdown systems have been shown to have applications for malware detection and XML schema checking \cite{senda2021forward, senda2021ltl}. 
In theory, since registers can be unfilled and later be filled again an unbounded number of times, the number of different data values a pushdown register systems can store in its registers in a run is unbounded.  
In \cite{murawski2017reachability} it was shown however that a register pushdown automaton can
only really ``remember'' at most  $3r$ data values, where $r$ is the number of registers,
i.e. for any run of a register pushdown automaton with $r$ registers there exists an equivalent run 
 with the same initial and final conﬁgurations, but in which every configuration contains register assignments drawn from only $3r$ elements. This  
 leads to
 the
  question
  of
   how useful the ability to unfill and later refill registers really is compared to a model that would only specify valuations once.






Another closely related formalism is that of alternating tree automata with nested pebbles. The approach of extending tree automata with pebbles was used in \cite{milo2000typechecking} to show that the XML typechecking problem is decidable, and in \cite{karhumaki2012jewels} to recognize first-order logic on trees. In both cases however, the input trees considered are finite, while 
simulation of plays in parametric pushdown graphs
requires the use of pebble alternating tree automata working on infinite trees
since the stack of a pushdown system is in general unbounded.



The aim of the present paper is to study the decidability and complexity of
deciding
the winner of a parity game on a graph of a pushdown system with  
parametric guards.


 

\subsubsection*{Our contributions}


Our main result consists in
proving parametric pushdown parity games belong to $(n+1)$-$\EXP$ in case the number of parameters
$n$ is fixed,
and providing a nonelementary lower bound for parametric pushdown parity games in general.

	For the upper bound, we start by replacing parameters by pebbles acting as registers, leading to a more general model, pebble pushdown systems.
 We then show that higher-order pushdown systems parity games can be used to solve parity games on
 the transition systems of pebble pushdown systems,
using one additional stack level for each pebble.
 Since solving parity games on higher-order pushdown systems with level $n$ stack is $n$-$\EXP$-complete \cite{ Cach03, cachat2007complexity}, this provides an $(n+1)$-$\EXP$ upper bound for solving parametric parity games on parametric pushdown systems with $n$ parameters.

	For the nonelementary lower bound,
we reduce the $\FO$ satisfiability problem on words, known to be nonelementary
from \cite{Sto74}, to the
problem of deciding whether a player has a winning strategy for parametric pushdown parity games. 





\section{Preliminaries}


\newcommand{\LCM}{\mathsf{LCM}}
\newcommand{\LOGSPACE}{\mathsf{LOGSPACE}}
\renewcommand{\MSO}{\mathsf{MSO}}
\newcommand{\SO}{\mathsf{SO}}

By $\Z $ we denote the {\em integers} and by $\N=\{0,1,\ldots\}$ we denote the {\em naturals}.
For every finite alphabet $A$, $A^*$ is the set of finite
words with letters in  $A$, $A^\omega$ is the set of infinite words with letters in $A$, and
 $A^\infty = A^\omega \cup A^*$. We denote the empty word in $A^*$ by $\epsilon$.


 For any two sets $X$ and $S$, let $X^S$ denote the set of all functions from $S$ to $X$.
For any set $S$ let 
$\mathcal{P}(S) = \{ X \mid X \subseteq S \}$
denote the power set of $S$.
%
A {\em partial function} $f$ from a set $X$ to a set $Y$ is a function defined on a subset $C$ of $X$ (possibly $X$ itself) with output values in $Y$. We extend the domain of a partial function to the whole set
by considering it as returning the bottom element $\bot$ when it is undefined.




A {\em graph} $G=(V,E)$ is a finite set of graph vertices $V$ with a set of graph edges $E \subseteq V \times V$. 
For any set $V$, and a given infinite sequence $\pi = v_0 v_1 \ldots \in V^\omega$ of elements of $V$, we define the set 
$\text{\textit{Inf}}(\pi)$ of elements occurring infinitely often in $\pi$ as
$\text{\textit{Inf}}(\pi) = \{ v \in V \mid \forall i, \exists j > i, ~ v_j = v \}$. 








A {\em game} is composed of an arena and a winning condition.
We will ﬁrst study
arenas and
 then introduce common winning conditions that will be of interest to us.



An {\em arena} is a tuple $A=(S_0, S_1,{\rightarrow})$  which is composed of two  disjoint  sets of configurations, $S_0$ and $S_1$, 
	whose disjoint union $S_0 \cup S_1$ we denote by $S$, and
 a relation of  
		transitions
	 ${\rightarrow} \subseteq S \times 	S$. 
Note that $(S,{\rightarrow})$, where $S=S_0 \uplus S_1$, forms
a   
transition system, and, in particular, given a  
transition system,
one needs only to provide 
a partition of the set of configurations $S$ into two sets $S_0$ and $S_1$ to obtain an arena.

The games we are interested in are played by two players, called {\em player $0$} and {\em player $1$}. We will often write player $i$ to denote a general player for $i \in \{0,1 \}$,
and we will call player $1-i$ its {\em opponent}. 
A {\em play} in an arena $A=(S_0,S_1,\rightarrow)$ is a path in $(S,{\rightarrow})$ that is {\em maximal} in the following sense: it is either infinite or finite and if it is finite, then the target configuration is a dead end. 
A {\em partial play} in an arena $A=(S_0,S_1,\rightarrow)$ is a 
% sequence of configurations $s_{init} = s_0 s_1 \ldots \in S^\infty$ connected by the transition relation, i.e. such that $(v_i, v_{i+1}) \in T$.
prefix of a play in $A$.
Essentially plays can be seen as this: the two players, player $0$ and player $1$, move along the labeled transition system, taking turns either inﬁnitely often or until a dead end is reached.





A {\em strategy} for player $i \in \{ 0,1\}$ is a function $\sigma_i : S^* S_i \to S$ such
that $\sigma_i(ws)$ is a successor of $s$.
%
A strategy is called {\em memoryless} if its output only depends on the final configuration of the sequence $s \in S_i$, i.e. if $\sigma_i(ws) = \sigma_i(w's)$ for all $w,w' \in S^*$. Thus, a memoryless strategy for player $i$ can be written  as a function $\sigma_i: S_i \to S$.

A partial play $\pi = s_0 \rightarrow s_1 \rightarrow \ldots \rightarrow s_n$ is {\em consistent} with a strategy $\sigma_i$ if sequences of configurations that end in $S_i$ along this play have all successors according to the strategy, i.e.
if for all $j\in[0,n-1]$, for all element $v_j \in V_i$ in the sequence $\pi$,
$v_{j+1} = \sigma_i(v_j)$.
 Given a configuration $s$,   a strategy $\sigma_0$ for player $0$ and a strategy $\sigma_1$ for player $1$, the play starting with $s$ that is consistent with both strategies is unique and is called the {\em resulting play} of $\sigma_0$ and $\sigma_1$ starting from $s$. It is 
denoted by $\pi(s, \sigma_0, \sigma_1)$.



Once we have provided players with an arena, it remains to define  properly what the winning condition is in order to define a game. Given an arena $A = (S_0, S_1, \rightarrow)$, a {\em winning condition}
$\win$
is a subset  
of the set of maximal plays for $A$. A {\em game} is a pair $\mathcal{G}= (A, \win)$ which is composed of an arena $A$ and a winning condition $\win$.
Although a winning condition is in general an infinite object we are interested in parity games winning conditions, 
which can finitely be described. In 
{\em parity games},
the winning condition $\win_\Omega(S)$ is given by a {\em priority function} 
 $\Omega : S \to  [0, m]$.
An infinite path $ \pi = s_0 s_1 s_2 \ldots$ is in $\win_\Omega(S)$ if the smallest priority appearing infinitely often in
the sequence 
 is even, i.e.
if $\min( \{ \Omega(s) | ~ s \in \text{\textit{Inf}}( \pi) \})$ is even.  
A finite play is in $\win_\Omega(S)$ if its target configuration is in $S_1$.
We simply write
$\win_\Omega$ in case the set $S = S_0 \biguplus S_1$ is obvious from context.

A strategy $\sigma_0$ for player $0$ from position $s \in S$ is a {\em winning strategy
 from $s$} for player $0$ if 
every maximal play starting from $s$ and consistent with $\sigma_0$ is in $\win$.
On the other hand, a strategy $\sigma_1$ for player $1$ from position $s \in S$ is a {\em winning strategy
 from $s$} for player $1$ if 
every maximal play starting from $s$ and consistent with $\sigma_1$ is not in $\win$.
 













One important property of parity games is that of {\em memoryless determinacy}: for a parity game
$\mathcal{G}= ((S_0,S_1,\rightarrow),\win_\Omega) $ and an initial configuration $s \in S_0 \cup S_1$, one of the players has a memoryless winning strategy from $s$ \cite{zielonka1998infinite}.



\section{Parametric pushdown games}



Parametric pushdown systems extend pushdown systems by allowing the stack to be compared against parameters that can be assigned values which are words over the stack alphabet.
A parametric pushdown automaton is then a finite automaton extended with a finite set of parameters $P$  and with a stack that can be manipulated by pushing or popping stack symbols and such that, moreover, the automaton can use the top of the stack, or check that the stack content corresponds to a parameter,  to decide which transition to take next.\\

\par\noindent\ignorespacesafterend
A {\em parametric pushdown system} ({\em PPDS} for short) 
is a tuple $\mathcal{Z} = (Q, \Gamma, P, R, q_{init},\gamma_{init}),$ where
 $Q$ is a non-empty finite {\em set of  states};
 $\Gamma$ is a non-empty finite {\em  stack alphabet};
 $P$ is a finite {\em   set of parameters}, \textcolor{black}{with $\Gamma \cap P = \emptyset$};
  $R   \subseteq  Q  \times (\Gamma \biguplus P)  \times Q  \times \Op(\Gamma)$ is finite {\em  set of rules};
 $q_{init}\in Q$ is an {\em initial  state};
 $ \gamma_{init} \in \Gamma$ is an {\em initial stack symbol}.


The {\em size} of $\mathcal{Z}$ is defined as
$|\mathcal{Z}| = |Q| + |\Gamma| + |P| + |R| $.
We also refer to $\mathcal{Z}$ as an $n$-parametric pushdown automaton if $|P| = n$.
A {\em stack content} is a word from $ \Gamma^*$. 
As before we write the top
of the stack at the right of the word. 
By $\Conf(\mathcal{Z})=Q\times  \Gamma^*$ we denote the set of
{\em configurations} of $\mathcal{Z}$. As usual we rather write $q(w)$ instead of $(q, w)$.
A {\em parameter valuation} is a function $\mu$ from $P$ to $\Gamma^*$.

\begin{samepage}
A parametric pushdown automaton  $\mathcal{Z}= (Q, \Gamma, P,u R, q_{init}, \gamma_{init})$ 
and a parameter valuation $\mu: P\rightarrow \Gamma^*$ induce the 
transition system  
$T_{\mathcal{Z}}^{\mu} = (\Conf(\mathcal{Z}), 
\rightarrow_{\mathcal{Z},\mu})$ where
for all $ q, q'  \in  Q$, 
for all $ w,w' \in \Gamma^* $, and 
for all $ a  \in  \Gamma$, 
$q(wa) \rightarrow_{\mathcal{Z},\mu} q'(w')$
if there exists a rule in $R$
 of the form $(q,a,q', op)$ or $(q,p,q', op)$ with $\mu(p)=wa$,
such that
either of the following holds
\begin{itemize}
\item $ op = \text{\textit{push}}^\gamma$ and $w' = wa\gamma$,

\item $ op = \text{\textit{pop}}$ and $w' = w$, or

\item $ op = \text{\textit{skip}}$ and $w' = wa$.
\end{itemize}
\end{samepage}








\textbf{PPDS games.}
We are interested in this article in parametric variants of parity games.
One goal may be to characterize the set of all possible parameter valuations for which a player has a winning strategy in a parity game
played on the arena induced by the
resulting concrete automaton
and some partition of its set of states. 
For determining such a set of parameter valuations, we incorporate the choice of the parameter valuation to the game. Each player then wants the parameter valuation to lead to an arena where it has a winning strategy.

In keeping with the spirit of alternation between players choosing successors in the arena, we consider here games where players
alternate choosing values for the parameters before alternating choosing successor configurations in the game on the induced arena.
For simplicity's sake, the values are assigned to the parameters one by one, alternating between values assigned by player $0$ and by player $1$.

For an  $n$-parametric pushdown automaton 
$\mathcal{Z}= (Q, \Gamma, P, R, q_{init}, \gamma_{init})$,
and a partition
$P = P_0 \biguplus P_1$,
we introduce first arenas over the set of partial parameter valuations. The values are assigned to the parameters one by one, alternating between values assigned by player $0$ (corresponding to parameters in $P_0$) and by player $1$ (corresponding to parameters in $P_1$). Other options could have been considered: for instance, we could consider a fully existential approach 
(i.e. all parameters have their values assigned by player $0$), 
or a fully universal approach
(i.e. all parameters have their values assigned by player $1$). 
Note however that the approach considered here encompasses both of the latter approaches:
the fully existential approach consists in the case where $P_1 = \emptyset$ and
the fully universal one, the case $P_0 = \emptyset$.


Assume an ordering of the parameters $P_0 \biguplus P_1 = \{p_0, p_1, \ldots, p_k \}$ for some 
 $k \in \N$, the {\em parameter valuation arena} is a tuple $A_{P_0,P_1,\Gamma} = (S_0, S_1, \rightarrow_P)$ where
\begin{itemize}

\item $S_0$ is the set of all partial parameter valuations with images in $\Gamma^*$ and domain $\{p_0, p_1, \ldots, p_{j}\} \setminus \{p_j\}$ where $\p_j \in P_0$,

\item $S_1$ is the set of all partial $\M$-parameter valuations  with images in $\Gamma^*$ and  domain $\{p_0, p_1, \ldots, p_{j}\} \setminus \{p_j\}$ where $\p_j \in P_1$,

\item
$ \mu \rightarrow_P \mu'$,
if $\mu' \in (\Gamma^*)^{\{p_0, \ldots, p_j\}}$ for some $j \in [0,k]$,
$\text{Dom}(\mu) = \text{Dom}(\mu') \setminus \{p_j\}$
and
 $\mu'(p) = \mu(p)$ for $p \in \text{Dom}(\mu)$. \label{parametric arena}
\end{itemize}


The arena has dead ends which correspond to parameter valuations.
Given a strategy $\sigma_0$ for player $0$ and a strategy $\sigma_1 $ for player $1$,
the last configuration of the resulting play $\pi(\mu_\bot,\sigma_0, \sigma_1)$
is called {\em the resulting parameter valuation}
 and is denoted by $\mu_{\sigma_0, \sigma_1}$, where 
 $\mu_\bot$ is the partial parameter valuation with domain $\emptyset$. 
The parametric valuation arena is a prefix of the full parametric games: once the resulting parameter valuation is produced by the two players, it serves to instantiate the transition system for continuing the game.
%
%

We then obtain the full parametric game's arena $A_{(\mathcal{Z}, P_0, P_1, Q_0 , Q_1)}$ by, for every configuration $\mu$ in $A_{P_0,P_1,\Gamma^*}$,
 adding a transition
from $\mu$ towards the initial configuration
$(q_{init}(\gamma_{init}), \mu)$ 
of
the arena
$
A_{(\mathcal{Z}, Q_0, Q_1, \mu)}
=
(Q_0\times \Gamma^*, Q_1\times \Gamma^*, \rightarrow_{\mathcal{Z},\mu})$
with configurations additionally including $\mu$ in the tuple.



 
 \label{PPDA reachability game}



We extend any 
priority function $\Omega: Q \to [0, m]$
into
$\widehat{\Omega}: \Conf(\mathcal{Z}) \cup (\Gamma^* \cup \bot)^{[0,n]} \to [0, m]$,
where we set
$\widehat{\Omega}(q, w, \mu) = \Omega(q)$
for all
$w \in \Gamma^*$
and
for all $\mu \in (\Gamma^*)^{P}$,
and
$\widehat{\Omega}(\mu) = 0$
for all $\mu \in (\Gamma^* \cup \bot)^{P}$. We consider the following decision problem.


\problemx{Parametric pushdown parity game}
{A parametric pushdown automaton $\mathcal{Z}= (Q, \Gamma, \{p_0, p_1, \ldots, p_k \}, R, q_{init}, \gamma_{init} )$, where $Q = Q_0  \biguplus Q_1 $, and $ P = P_0 \biguplus P_1$, 
and a priority function $\Omega: Q \to [0, m]$.}
{Does player $0$ have a winning strategy from $\mu_\bot$ in the parity game \\
$\mathcal{G} =(A_{(\mathcal{Z}, P_0, P_1, Q_0 , Q_1)}, \win_{\widehat{\Omega}})$ ?\newline}





We write 
{\sc $n$-parametric pushdown parity game} if 
 the number of parameters $n=|P|$ of $\mathcal{Z}$ is fixed by the problem.



			
\section{Reduction to pebble pushdown systems parity games
}\label{pebbles}


A pebble automaton is a two-way finite state automaton that uses a fixed, finite number of
pebbles that it can drop on, and lift from 
words, using them as markers.
Pebble automata recognize regular languages only, provided the life times of the pebbles, i.e. the times between dropping a pebble and lifting it again, are properly nested
\cite{globerman1996complexity, engelfriet1999tree}.
Automata with nested pebbles were also introduced
for tree-walking automata. 
It is known that tree-walking automata do not recognize all regular tree languages \cite{bojanczyk2008tree}.
Using pebbles is a remedy against getting lost along a tree, but 
the unrestricted use of pebbles leads to a class of tree languages much larger than the
regular tree languages, in fact to all tree languages in $\NSPACE(log ~ n)$.
It is traditional since pebbles follows a strict stack discipline to represent syntactically the dropping and lifting of pebbles by operations \textit{lift} and \textit{drop}; a \textit{drop} simply records the current position with a fresh pebble (such a pebble should be available)  and a \textit{lift} pops the last dropped pebble if the current position corresponds to the one recorded by it.




In this section, we extend these ideas to pushdown systems. Instead of using pebbles as markings on their input, pebble pushdown systems have the ability to lift or drop pebbles on their universe of stack contents; a \textit{drop} simply records the current stack content with a fresh pebble (such a pebble should be available)  
and a \textit{lift} pops the last dropped pebble 
while requiring that
 it was placed on the current node. 
One can think of a pebble as a register that can store a stack content for later comparisons.





\paragraph*{Pebble pushdown systems}

\newcommand{\ppda}{\mathcal{I}}


An {\em $n$-pebble pushdown automaton} 
is a tuple 
$\ppda = (Q, \Gamma,  R, q_{init}, \gamma_{init})$
where $Q$ is a {\em finite set of  states}; $\Gamma$ is a {\em finite stack alphabet};
  $R  \subseteq  Q  \times \Gamma \times
		 \{ 0, 1, \ldots n\} \times \mathcal{P}(\{1,\ldots,n\})
		 \times Q  \times (\Op(\Gamma) \cup \{\text{\textit{drop}}, \text{\textit{lift}}\})$ is a {\em finite set of rules},
		 where the fourth element $S$ of a rule $r$ is a subset of 
		$\mathcal{P}(\{1,\ldots,i\})$ where $i$ is the third element of $r$,
		and if the last element is
		$\text{\textit{lift}}$ then we additionally require $i \in S$;
 $q_{init} \in Q$ is an {\em initial  state};
 $\gamma_{init} \in \Gamma$ is an {\em initial stack symbol}.




Recall that for a partial function $ f : S \rightharpoonup X $, for notational purposes, we consider some element $\bot_X \not\in X$ and 
 associate $f$ with the function returning the 
bottom element $\bot_X$ when $f$ is undefined. Thus we write $(X \biguplus \{ \bot_X \})^S$ for the set of all partial functions from $S$ to $X$, which we here abbreviate as $(X \biguplus \{ \bot \})^S$. 



 
 


By $\Conf(\ppda)=Q\times \Gamma^* \times (\Gamma^* \biguplus \{ \bot \})^{\{1, \ldots, n\}}$ we denote the set of
{\em configurations} of $\ppda$. As expected, we rather write $q(w, \mu)$ instead of $(q, w, \mu)$.
An {\em$i$-configuration} for $i > 0$ of $\ppda$ is a configuration $q(z,\mu)$ where
$\text{Dom}(\mu) = \{1, \ldots, i\}$, while a $0$-configuration is a configuration 
 $q(z,\mu)$ where $\text{Dom}(\mu)=\emptyset$.



The idea of a transition $(q, a, i, S, q', m) \in R$
is that, if the automaton $\ppda$ is in state $q$ with pebbles $1,\ldots, i$ dropped \---- or without pebble dropped if $i = 0$ \---- with top stack symbol $a$, and stack content which corresponds to the stack contents of the pebbles from $S$ and only these pebbles, then
$\ppda$ goes to state 
$q'$ and makes modifications to the stack or the pebbles according to
$m$. 
Note a pebble 
can be lifted only if the stack content which corresponds to the pebble
is the same as the current stack content. 
This is enforced by syntactically requiring
the last pebble dropped $i$ is in the set $S$ used for testing the presence of  pebbles.




A {\em pebble set} of $\ppda$ is a set $U \subseteq \{ 1, \ldots, n\}$. For a stack alphabet $\Gamma$, a 
{\em $U \!$-pebble assignment} is a function which maps each $j \in U$ to a word in $ \Gamma^*$.
The $\emptyset$-pebble assignment is denoted by $\mu_{init} :  \{ 1, \ldots, n\} \rightharpoonup  \Gamma^* $ and is the 
totally undefined function.




An $n$-pebble pushdown automaton $\ppda =  (Q, \Gamma,  R, q_{init}, {\gamma_{init}} )$ induces 
a transition system  $T_{\ppda} = (\Conf(\ppda), \rightarrow_{\ppda})$ 
 such that
for all $(q, a, i, S, q', m) \in R$, with $a \in \Gamma$,
 for all words $w \in  \Gamma^*$, and for all $\{ 1, \ldots , i \}$-pebble assignments $\mu$ such that $\mu(j) = wa$ 
 for each
$j \in S$ 	and
 $\mu(j) \neq wa$ 
 for each $j \in \{ 1, \ldots , i \} \setminus S$,
the following holds
	%\begin{samepage}
\begin{itemize}
\item if $m \in \Op(\Gamma)$, 
either
\begin{itemize}
\item $ m = \text{\textit{push}}^\gamma$ and $(q,wa,\mu) \rightarrow_{\ppda} (q',wa\gamma, \mu)$,

\item $ m = \text{\textit{pop}}$ and $(q,wa,\mu) \rightarrow_{\ppda} (q',w, \mu)$, or

\item $ m = \text{\textit{skip}}$ and $(q,wa,\mu) \rightarrow_{\ppda} (q',wa, \mu)$,
\end{itemize}
\item if $ m = \text{\textit{drop}}$, 
$(q,wa,\mu) \rightarrow_{\ppda} (q',wa, \mu')$,  
where $\mu'$ is the $\{ 1, \ldots , i, i+1 \}$-pebble assignment such that
$\mu'(j) = \mu(j)$, for each
$j \leq i$, and $\mu'(i+1) = wa$, and
\item if $m = \text{\textit{lift}}$, and $i \in S$, i.e. the last pebble dropped belong of the set of pebble we test the presence of,
$(q,wa,\mu) \rightarrow_{\ppda} (q',wa, \mu')$, 
where $\mu'$ is the $\{ 1, \ldots , i - 1 \}$-pebble assignment such that
$\mu'(j) = \mu(j)$, for each
$j < i$.
\end{itemize}
	%\end{samepage}




Again, given
a 
 transition system, one needs only to provide 
a partition of the set of
configurations 
 to obtain an arena.
 %
Given a partition of
$Q$ into $Q_0$ and $Q_1$, 
we partition the configurations of
$T_{\ppda}$
into
$\Conf_{\ppda,0}=Q_0\times \Gamma^* \times ( \Gamma^* \biguplus \{ \bot \})^{\{1, \ldots n\}}$
and
$\Conf_{\ppda,1}=Q_1\times  \Gamma^* \times ( \Gamma^* \biguplus \{ \bot \})^{\{1, \ldots n\}}$. 
We  define the arena
$
A_{(\ppda, Q_0 , Q_1)}
=
(\Conf_{\ppda,0}, \Conf_{\ppda,1}, \rightarrow_{\ppda}).$
As expected, given a 
priority function $\Omega: Q \to \{0, \ldots m\}$,
one naturally 
set the extension of $\Omega$ as
$\overline{\Omega}: \Conf(\ppda) \to \{0, \ldots m\}$
and
$\overline{\Omega}(q, w,\mu) = \Omega(q)$
for all
$w \in  \Gamma^*$
and
$\mu \in ( \Gamma^* \biguplus \{ \bot \})^{\{1, \ldots, n\}}$. \\

Concerning pebble pushdown systems, we are interested in the following decision problem.


\problemx{$n$-pebble pushdown parity game}
{An $n$-pebble pushdown automaton $\ppda= (Q, \Gamma,  R, q_{init}, {\gamma_{init}})$, 
where $Q = Q_0  \biguplus Q_1 $, 
and
a priority mapping $\Omega: Q \to \{0, \ldots m\}$.}
{Does player $0$ have a winning strategy from $q_{init}(\gamma_{init}, \mu_{init})$ for the parity game 
$\mathcal{G}= (A_{(\ppda, Q_0 , Q_1)}, \win_{\overline{\Omega}})$ ? \\}


Since pebbles can store stack contents, they can be used to simulate parameters. From this we deduce the following theorem. See Appendix~\ref{appendix A} for more details on the construction.


\begin{theorem}\label{PPDA reduction}
{\sc $n$-parametric pushdown parity game} 
is polynomial time reducible to
{\sc $n$-pebble pushdown parity game}.
\end{theorem}






\section{Reduction to higher-order pushdown systems}\label{section HPDA}




Higher-order pushdown systems (HPDS for short) were introduced as a 
generalization of pushdown systems \cite{aho1969nested,Gre70,maslov1976multilevel}. 
A stack of a pushdown automaton is seen as a {\em level $1$ stack}. 
A pushdown automaton of level $2$ (or $2$-HPDS) then works with a stack of level $1$ stacks. 
In addition to the ability to push
and to pop a symbol on the top-most level $1$ stack, an $2$-HPDS can copy or remove the entire topmost level $1$ stack. 
The definition generalizes to any $n \geq 2$, and $n$-HPDS are similarly defined for all level
$n$ as systems working with a stack of level $(n-1)$ stacks.




We recall the definition from \cite{cachat2007complexity} which itself is taken from \cite{knapik2002higher}. We then provide a
reduction from the problem of solving pebble pushdown parity games to the problem of solving
higher-order pushdown parity games.


\paragraph*{Higher-order pushdown systems}

A {\em level $1$ stack} (or {\em $1$-stack}) over an alphabet $\Gamma$ is 
simply a 
	stack over $\Gamma$, i.e. a word  in $\Gamma^*$.
A  {\em level $n$ stack} (or {\em $n$-stack}) over an alphabet $\Gamma$, for $n \geq 2$, is a 
non-empty sequence
$ \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle$
of
$(n-1)$-stacks over $\Gamma$,
for some $m \in \N$.
The set of $n$-stacks over $\Gamma$ is denoted by $\mathscr{S}_n(\Gamma)$,
or simply $\mathscr{S}_n$ in case the set $\Gamma$ is obvious from context.
The set of all stacks over $\Gamma$ is written $\mathscr{S}(\Gamma) = \bigcup_{n\in \N} \mathscr{S}_n(\Gamma)$.
We define $\epsilon_{1}$ as
$\epsilon \in \Gamma^*$ and we inductively define 
$\epsilon_{n} = \langle \epsilon_{n-1} \rangle$ in $\mathscr{S}_n$ for all $n > 1$.




A {\em higher-order stack operation} is a partial function from $\mathscr{S}(\Gamma)$ 
to $\mathscr{S}(\Gamma)$ which preserves the level of the input (i.e. the image of
an $n$-stack is an $n$-stack for all $n \in \N$). The {\em level } of an operation $op$
is the smallest $n \in \N$ such that $\text{Dom}(op) \cap \mathscr{S}_n \neq \emptyset$. 
The operations 
additionally
 respect the hierarchicality of higher-order stacks, i.e. in
a level $n+1$ stack only the topmost level $n$ stack can be accessed. An operation
$op$ of level $n$, applied to a level $n+1$ stack 
$ \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle$
of length $m \in \N$,
thus
returns the output
$ \langle s_0 \rangle \langle s_1 \rangle \ldots \langle op(s_m) \rangle$
if applicable.
The definition for  all levels of stacks greater than $n$ follows the same pattern.



The following operations can be performed on a $1$-stacks of length $m \in \N$.
\begin{eqnarray*}
&\text{\textit{push}}_1^\gamma( w_0 w_1 \ldots w_m) &=\quad w_0 w_1 \ldots w_m \gamma   \text{ for all } \gamma \in  \Gamma, \\
&\text{\textit{pop}}_1(w_0 w_1 \ldots w_{m-1} w_m ) &=\quad w_0 w_1 \ldots w_{m-1}, \text{ if } m \geq 1\\
&\text{\textit{top}}( w_0 w_1 \ldots w_m ) &=\quad w_m.
\end{eqnarray*}
The operations added at level $n+1$ are the copy of the topmost $n$-stack
and the removal of the topmost $n$-stack.
More formally, if $ \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle$ is a stack of 
level $n > 1$, 
the following operations are possible. 
%
\begin{eqnarray*}
&\text{\textit{push}}_n( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle) &=\quad  \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle \langle s_m \rangle , \\
&\text{\textit{push}}_j( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle) &=\quad \langle s_0 \rangle, \langle s_1 \rangle \ldots 
\langle \text{\textit{push}}_j(s_m) \rangle,
\text{ if } 2 \leq j < n\\
&\text{\textit{push}}_1^\gamma( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle) &= \quad
\langle s_0 \rangle \langle s_1 \rangle \ldots 
\langle \text{\textit{push}}_1^\gamma(s_m) \rangle,
\text{ for all } \gamma \in \Gamma,\\
&\text{\textit{pop}}_n( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_{m-1} \rangle \langle s_m \rangle) &= \quad
\langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_{m-1} \rangle
,\\
&\text{\textit{pop}}_j( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_{m-1} \rangle \langle s_m \rangle) &= \quad
\langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_{m-1} \rangle
\langle \text{\textit{pop}}_j(s_m) \rangle,
\text{ if } 1 \leq j < n\\
&\text{\textit{top}}( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle) &=\quad
\text{\textit{top}}(s_m).
\end{eqnarray*}
The operations $pop_1$ and $top$ are undefined on a stack whose top $1$-stack is empty.  


Given a stack alphabet $\Gamma$ and $n \in \N$, 
we denote by  $\Op_n(\Gamma)$ the {\em base set of $n$-stack operations} as

\begin{itemize}
\item $\text{\textit{push}}_j$ for all $2 \leq j \leq n$,

\item $\text{\textit{push}}_1^\gamma$ for all $\gamma \in \Gamma$,

\item $\text{\textit{pop}}_j$ for all $1 \leq j \leq n$,

\item $\text{\textit{skip}}$, corresponding to the identity function of $\mathscr{S}(\Gamma)$.

\end{itemize}





\begin{samepage}
\par\noindent\ignorespacesafterend
A {\em higher-order pushdown systems of level $n$} (or $n$-HPDS for short) 
is a tuple $\H=(Q, \Gamma, R, q_{init}, \gamma_{init})$,
where 
 $Q$ is a non-empty finite {\em set of  states} ;
         $\Gamma$ is a non-empty finite {\em  stack alphabet};
	 $R\subseteq Q\times \Gamma \times Q \times \Op_n(\Gamma)$ is a finite {\em set of  rules};
         $q_{init}$ is the {\em initial  state} ;
         $\gamma_{init} \in \Gamma$ is the {\em %bottom-of-stack
initial stack symbol}.
\end{samepage}


By $\Conf(\mathcal{H}) = Q \times \mathscr{S}_n(\Gamma)$
we denote the set of {\em configurations} of an $n$-HPDS $\H$. 
As usual we abbreviate $(q,s) \in \Conf(\mathcal{H})$ as $q(s)$.
An $n$-HPDS $\H=(Q, \Gamma, R, q_{init})$
induces the transition system $\T_\H = (Conf(\mathcal{H}), \rightarrow_{\mathcal{H}})$
where
for all $q,q'$ in $Q$,
for all $s,s'$ in $\mathscr{S}_n(\Gamma)$,
$q(s) \rightarrow_{\mathcal{H}} q'(s')$ if
there exists some rule
$(q,\gamma,q',op) \in R$
such that
$\text{\textit{top}}(s) = \gamma$
and
$s' = op(s)$.





Again we are interested in parity games.
As expected, given an 
 $n$-HPDS $\mathcal{H}$
 and a partition of
$Q$ into $Q_0$ and $Q_1$,
we partition the configurations of
$T_{\mathcal{H}}$
into
$\Conf_{\mathcal{H},0}=Q_0\times \mathscr{S}_n(\Gamma)$
and
$\Conf_{\mathcal{H},1}=Q_1\times\mathscr{S}_n(\Gamma)$.
%
%
With these notations in mind one can define the arena
$
A_{(\mathcal{H}, Q_0, Q_1)}
=
(\Conf_{\mathcal{H},0}, \Conf_{\mathcal{H},1}, \rightarrow_{\mathcal{H}})$
induced by an $n$-HPDS $\mathcal{H}$ and a partition of its set of states.


As expected, given a 
priority function $\Omega: Q \to [0, m]$,
we naturally extend the function
as follows,
by setting
$\Omega_{\mathscr{S}_n(\Gamma)}: \Conf(\mathcal{H}) \to [0, m]$
and
$\Omega_{\mathscr{S}_n(\Gamma)}(q, s) = \Omega(q)$
for all
$s \in \mathscr{S}_n(\Gamma)$.





Concerning higher-order pushdown systems, we are interested in the following decision problem. 

\begin{samepage}
\problemx{$n$-HPDS parity game}
{An $n$-HPDS $\H= (Q, \Gamma,  R, q_{init}, {\gamma_{init}})$, 
where $Q = Q_0  \biguplus Q_1 $, 
and
a priority mapping $\Omega: Q \to \{0, \ldots m\}$.}
{Does player $0$ have a winning strategy 
from $q_{init}(\text{\textit{push}}_1^{\gamma_{init}}(\epsilon_{n}))$ 
for the parity game 
$\mathcal{G}= (A_{(\H, Q_0 , Q_1)}, \win_{\Omega_{\mathscr{S}_n(\Gamma)}})$ ?\newline}
\end{samepage}

It was shown in \cite{Cach03} that {\sc $n$-HPDS parity game} can
be solved in $n$-$\EXP$. This also gives an $n$-$\EXP$ algorithm for the $\mu$-calculus
model checking over transitions systems induced by  $n$-HPDS.
In \cite{cachat2007complexity} the matching lower bound was showed, even in the case of reachability games,
hence showing $n$-$\EXP$-completeness of {\sc $n$-HPDS parity game}.

\begin{theorem}{\cite{ Cach03, cachat2007complexity}}
{\sc $n$-HPDS parity game} is $n$-$\EXP$-complete.
\end{theorem}





In a $2$-HPDS, the operation $\text{\textit{push}}_2$ 
allows to ``copy'' the top level $1$ stack. The current word is hereby stored away and left untouched
until the next operation $\text{\textit{pop}}_2$,
while $\text{\textit{push}}_1$ and $\text{\textit{pop}}_1$ can be performed on the additional ``copy'' in the meantime. This behavior is similar to that of dropping and lifting a pebble. 
The main difference is that there is no operation to test that the ``copy'', after many updates, is again equal to the ``original'', i.e. there is no operation to syntactically test that the two topmost level $1$ stacks are identical.





In \cite{CaWoe03, Woeh05, carayol2006automates} however 
Carayol and W\"ohrle
 introduced a variant of $n$-HPDS by extending the 
$\text{\textit{pop}}_j$ operations for $2 \leq j \leq n$ with a built-in equality test. 
For $2 \leq j \leq n$ 
the new operation
$\text{\textit{pop}}_j^=$ has the same effect as $\text{\textit{pop}}_j$, but
can only be applied if the two top level $j$ stacks coincide.
In \cite{carayol2006automates} it is seen as a symmetrical operation in comparison to
$\text{\textit{push}}_j$.\\

A {\em higher-order pushdown automaton with equality pop of level $n$} ($n$-HPDS$^=$ for short) 
is a higher-order pushdown automaton of level $n$ where in
$\Op_n(\Gamma)$
 the operation 
 $\text{\textit{pop}}_j$  
  is replaced by 
$\text{\textit{push}}_j^=$
for $2 \leq j \leq n$.
We denote
this new set of operations by 
$\Op_n^=(\Gamma)$. 
More formally the new operations $\text{\textit{push}}_j^=$ are defined as
\begin{eqnarray*}
&\text{\textit{pop}}_k^=( \langle s_0 \rangle \langle s_1 \rangle \ldots  \langle s_m \rangle \langle s_m \rangle) &=\quad  \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle , \quad \text{ and }\\
&\text{\textit{pop}}_j^=( \langle s_0 \rangle \langle s_1 \rangle \ldots \langle s_m \rangle) &=\quad \langle s_0 \rangle \langle s_1 \rangle \ldots 
\langle \text{\textit{pop}}_j^=(s_m) \rangle,
\text{ if } 2 \leq j < k. 
\end{eqnarray*}
%
%
%
%
Transition systems induced by higher-order pushdown systems with equality pop of level $n$
are then defined as expected.  
Carayol and W\"ohrle proved \cite{Woeh05, carayol2006automates} that the two models,
namely
higher-order pushdown systems with equality pop of level $n$
and
higher-order pushdown systems of level $n$,
generate the same classes of transition systems.





\begin{theorem}{\cite{Woeh05, carayol2006automates}}
If $\H$ is an $n$-HPDS (resp. $n$-HPDS$^=$) then there
exists an $n$-HPDS$^=$ (resp. $n$-HPDS) $\H'$ such that
$\H$ and $\H'$ 
induce isomorphic transition systems.
\end{theorem}



From $n$-HPDS to $n$-HPDS$^=$ (Proposition 3.12 in \cite{Woeh05}) the proof relies on recreating a correct stack content to simulate higher-order 
$\text{\textit{pop}}$ operations by $\text{\textit{pop}}^=$, essentially ``guessing'' the correct stack content to be able to apply $\text{\textit{pop}}^=$. 
In the other direction (Proposition 3.18 in \cite{Woeh05}), 
the author
enrich the stack alphabet with new symbols stating which 
instructions have to be executed to recreate a
previous stack content. It is proven that such en encoding is possible since
there is 
for every stack $s$ of level $n$
 a unique shortest sequence of instructions which creates $s$ from
$\epsilon_n$. \\

Defined like {\sc $n$-HPDS parity game}, we write {\sc $n$-HPDS$^=$ parity game}  
in case the input is an $n$-HPDS$^=$ rather than an $n$-HPDS.



The algorithm from \cite{Cach03} actually provides an algorithmic solution to parity games on the graphs of the Caucal hierarchy. 
We skip a formal definition of a graph of level $n$ in the Caucal hierarchy, and refer the reader
to \cite{Cau02mfcs} for more details.
The $n$-$\EXP$ upper bound on $n$-HPDS parity games follows from the fact that every transition system induced by an $n$-HPDS $\H$ is a graph of the Caucal hierarchy \cite{Cach03, Woeh05},
whose vertices are almost in one-to-one correspondence with the configurations of $\H$.
In \cite{Woeh05} the converse direction is proven, i.e. that every graph of level $n$
of the Caucal hierarchy is generated by an $n$-HPDS.  
%
%
In \cite{carayol2006automates}
it is similarly shown that
every transition system induced by an $n$-HPDS$^=$ $\H$ is a graph of the Caucal hierarchy.
%
%
The algorithm from \cite{Cach03} hence lead to a solution for
$n$-HPDS$^=$ parity games as well.





\begin{theorem}\label{HPDA parity game}
{\sc $n$-HPDS$^=$ parity game} is in $n$-$\EXP$.
\end{theorem}









\subsection{From pebble pushdown 
systems 
to higher-order pushdown 
systems
}



We use HPDS$^=$ parity games to simulate pebble pushdown systems
parity games.
A similar approach was used in \cite{carayol2006automates} to show that $(n + 2)$-level stack
systems could be used to simulate $n$-pebble alternating two-way word systems.


Let us start by discussing the simulation of the dropping and lifting of a pebble in the case of
a pebble pushdown automaton $\ppda$ with only one pebble.
As long as no pebble is dropped, a $2$-HPDS$^=$ $\H$ can simulate 
the behavior of a pebble pushdown automaton $\ppda$ with a $2$-stack containing a single $1$-stack
on which it performs the same operations $\ppda$ performs on its stack.
When the automaton $\ppda$ is in configuration $q(w)$ and drops a pebble, instead of making a pop or a push, we need
to
	store the information that the pebble has been
dropped on $w$.
To simulate the next configuration in such a case, we use 
$\text{\textit{ push}}_2$
to store the information that the pebble has been dropped on the word $w$, leading to the new  $2$-stack
$\langle w \rangle \langle w \rangle$. 
Configurations afterwards have $2$-stacks of length two where the first component remains
$w$ until the pebble is lifted.
Lifting the pebble can be done only at the position the
pebble was dropped, by using $\text{\textit{pop}}^=_2$.
Checking that the node
corresponds to the one where the pebble has been dropped simply makes use of
the composition of $\text{\textit{pop}}^=_2$ and $\text{\textit{push}}_2$.
Checking the absence of the pebble can be done by challenging
the opponent to prove the presence of the pebble.

Now, let us detail the case when there is a second pebble, the construction
for each additional pebble being highly similar, where every additional pebble after
the first one would require the addition of another stack level.
Similarly as before, 
as long as no pebble is dropped, the stack of $\H$ 
is a $3$-stack containing a
single $2$-stack that contains a single $1$-stack.
To simulate configurations in the case one pebble have been dropped, the stack contains a single
 $2$-stack of the form $\langle w_1 \rangle \langle w \rangle$.
In the case the two pebbles have been dropped, 
the stack is of the form $ \langle \langle w_1 \rangle \langle w_2 \rangle \rangle
\langle \langle w_1 \rangle \langle w \rangle \rangle$. 



Intuitively speaking, $w_1$ is, as before, the position where the first pebble is
placed, and $w_2$ is where the second pebble is placed. Dropping pebbles like this
again involves the cloning operation, only, each pebble operates at a different 
stack level: thus, dropping the first pebble will use $\text{\textit{push}}_2$
and dropping the second pebble will use $\text{\textit{push}}_3$. Knowing the number of pebbles dropped can be done by 
keeping track using the states of $\H$.
Lifting or
checking for the presence 
(or absence) 
of the pebbles functions on a similar
basis as before. Checking the presence of the first pebble uses 
operation $\text{\textit{pop}}^=_2$ followed by $\text{\textit{push}}_2$,
while checking the presence of the second pebble uses 
operation $\text{\textit{pop}}^=_3$ followed by $\text{\textit{push}}_3$.
Lifting the first pebble uses $\text{\textit{pop}}^=_2$, but
check first that the second pebble has already been lifted.
Lifting the second pebble simply uses $\text{\textit{pop}}^=_3$.


By expanding this reasoning inductively, we conclude that given $n \in N$, and
given an $n$-pebble pushdown automaton 
$\ppda = (Q, \Gamma, R, q_{init}, \gamma_{init})$, where $Q= Q_0 \biguplus Q_1$,
one can compute an $(n+1)$-HPDS 
$\H = (Q', \Gamma, R', q_{init}', \gamma_{init}')$  where $Q'= Q_0' \biguplus Q_1'$, 
such 
that 
player $0$ has a winning strategy from $q'_{init}(\text{\textit{push}}_1^{\gamma_{init}'}(\epsilon_{n}))$ in $A_{(\H,Q'_0,Q'_1)}$ 
if
and only if
player $0$ has a winning strategy from $q(\gamma_{init},\mu_{init})$ in $A_{(\ppda,Q_0,Q_1)}$. 
Hence the following reduction.

\begin{theorem} 
{\sc $n$-pebble pushdown parity game} is polynomial time reducible
to {\sc $(n+1)$-HPDS$^=$ parity game}.
\end{theorem}

The reduction implies decidability of pebble pushdown systems parity game. Furthermore,
by Theorem~\ref{HPDA parity game} and Theorem~\ref{PPDA reduction}, it implies the following complexity result.


\begin{theorem}
{\sc $n$-pebble pushdown systems parity game} and {\sc $n$-parametric pushdown systems parity game} are in $(n+1)$-$\EXP$.
\end{theorem}












\section{Lower bound}

The aim of this section is to show a nonelementary lower bound for the 
problem of deciding whether player $0$ has a winning strategy from some starting configuration in
a parametric pushdown parity game.


We reduce the satisfiability problem for first-order logic on words
to the problem of {\sc Parametric pushdown parity game}. 
We know from \cite{Sto74}
that satisfiability is nonelementary. 
%


We define the tower function $T : \N \times \R \to \R$ by $T(0,r) =r$ and
$T(h+1,r)= 2^{T(h,r)}$ for all $h \in \N, r \in \R$. Thus $T(h,r)$ is a tower of $2$s of height $h$ with an $r$ sitting on top.
Observe that for all $n,h \in \N$ with $n\geq 1$, we have
$T(h, log^{(h)}(n)) = n$.
%
% 
Here a problem is in ${\sf ELEMENTARY}$ if it can be solved in time $O ( T(n, 0) )$.

The satisfiability problem is concerned with the following question.
\begin{samepage}
\problemx{$\FO$ satisfiability on words}
{A  
$\FO$-sentence $\phi$.}
{Does there exists a word $w\in \{0, 1\}^*$, such that $w \models \phi$ ?\newline}
\end{samepage}



The result that is previously known and motivates the upcoming reduction consists in the following.


\begin{theorem}[\cite{Sto74}]\label{FOnonelementary}
The {\sc $\FO$ satisfiability on words} problem is not in {\sc ELEMENTARY}.
\end{theorem}





\subsection{Reduction from FO SAT on words}

The following theorem states a polynomial time reduction from
{\sc $\FO$ satisfiability on words}
towards the problem of 
{\sc Parametric pushdown parity game}.




\begin{samepage}
\begin{theorem}
{\sc FO satisfiability on words} is polynomial time reducible to {\sc Parametric pushdown parity game}.
\end{theorem}
\end{samepage}



\begin{proof}

\noindent
We start with
 a 
 $\FO$-formula $\phi$.
We assume without loss of generality that $\phi$ is written in the prenex normal form
$\phi = \forall x_1 \exists x_2 \forall x_3 \ldots \exists x_k ~ \psi$, where 
an even number $k$ of quantifiers alternate between existential and universal ones, and 
$\psi$ is quantifier-free and in disjunctive normal form.
We construct
a parametric parity game
in which
player $0$ has a winning strategy
if and only if
there exists a word $w \in \{0,1\}^*$ such that
$w  \models \phi $. 





Player $0$ starts by chosing a valuation $w$ for the first parameter (parameter $p_0$). The goal of this first parameter is to remember
the word $w$, which corresponds to the word ``guessed" by player $0$. 
This parameter is meant in part to enforce that 
the stack remains a prefix of $w$, with each stack content of the play corresponding to a position in the word.
 To enforce this, we allow in $\mathcal{Z}$, after any decision, for a player to challenge the assumption that the last movement of the other player led to a position in the word.
  A player thus challenged only has the ability to add things onto the stack, and win if and only if able to find a way back to the value of parameter $p_0$. 
The other parameters are meant to correspond to the variables, with player $1$ parameters corresponding to universal variables and player $0$ parameters corresponding to existential variables.

Once players have chosen values for their respective variables, the parameter assignment
$\mu$ is fixed. It is then time
for player $0$ to ensure that
$w$
satisfies $\psi$ if the variables $x_1, \ldots, x_k$ are interpreted by 
$ |\mu(p_1)|-1, \ldots, |\mu(p_k)|-1$ respectively. 
Recall $\psi$ is quantifier-free and in disjunctive normal form, i.e.
 $ \psi = %\forall x_1 \exists x_2 \forall x_3 \ldots \exists x_k 
 \bigvee_{i=1}^l(\bigwedge_{j=1}^{h_i} \psi_{i,j}(x_1, \ldots, x_k)).$
Player $0$, being the existential player, choses one of the conjunctive clause in $\psi$, essentially claiming to be able to prove it. Then player $1$, the universal player, chooses one of the atomic formula in the clause to test. 
Testing the atomic formula is the purpose of a gadget 
in which
 player $0$ has a winning strategy 
  if and only if 
$w$ satisfies 
the atomic formula
 if the variables $x_1, \ldots, x_k$ are interpreted by 
$ |f(1)|-1, \ldots, |f(k)|-1$ respectively.
The gadget will depend on the type of the atomic formula. For a formula checking the letter at the position of a variable $x$, player $0$ goes to the position corresponding to $x$, then checks that the top of the stack
$x$ is the right letter. For one checking that $x = x'$ where $x$ and $x'$ are both variables,
player $0$ goes to the position corresponding to $x$ and checks against the parameter corresponding to $x'$ as well. If the formula is a negation, players exchange their roles. 
\end{proof}

Then, the nonelementary lower bound follows from Theorem~\ref{FOnonelementary}. 



\begin{theorem}
{\sc Parametric pushdown parity game} is not in {\sc ELEMENTARY}.
\end{theorem}





\section{Conclusion}

In this paper we have shown that
deciding
the winner of a parametric parity game
is nonelementary, reducing the $\FO$ satisfiability problem on words \---- known to be nonelementary
from \cite{Sto74} \---- to the
problem of deciding whether player $0$ has a winning strategy from some starting configuration in 
a parametric pushdown parity game.

	For the upper bound, we replaced parameters by pebbles acting as registers, leading to a more general model, and then used a reducton to higher-order pushdown systems parity games to solve parity games. Since solving parity games on higher-order pushdown systems with level $n$ stack is $n$-$\EXP$-complete \cite{ Cach03, cachat2007complexity}, this provides an $(n+1)$-$\EXP$ upper bound for solving parametric parity games on parametric pushdown systems with $n$ parameters.


For solving parametric pushdown parity games we introduced the notion of pebble pushdown parity games.
Pebble pushdown automata over unary alphabet plus a bottom-of-stack symbol
can be seen as a form of one-counter automata extended with pebbles. 
A pebble one-counter automata is then a one-counter automata that
can use a set of pebbles as markings on the set of non-negative integers, with a 
$\text{\textit{drop}}$ recording the current counter value, and a 
$\text{\textit{lift}}$ poping the last dropped
pebble while requiring that the current counter value 
corresponds to the one from the last dropped pebble.
%
Unlike for parametric extensions, 
decidability of 
what should be called
pebble one-counter parity games follows from
decidability of pebble pushdown parity games. 
We believe it natural to study such a pebble one-counter automata model
on its own.
In particular we believe that the question of whether or not
solving pebble one-counter parity games is nonelementary is worth investigating.



Of note is that parity games are 
not the only problems one can consider, as one can
also explore the complexity of reachability. 
In particular
one can 
study the precise complexity of the
{\sc $n$-PPDA reachability} problem.
Since reachability can be viewed as a reachability game, which can be simulated using a parity game, we know that
{\sc $n$-PPDA reachability} is decidable in $(n+1)$-$\EXP$, 
but the precise complexity of the problem remains unknown.
We are furthermore convinced that it is worthwhile to investigate further comparisons between parametric pushdown automata, pebble pushdown automata, 
and register pushdown automata, especially since the latter have been shown to only really ``remember'' at most  $3r$ data values, where $r$ is the number of registers. 




\bibliography{bibliography/bib}




\appendix


\setcounter{theorem}{0}

\section{From parametric pushdown 
systems 
to pebble pushdown systems
}\label{appendix A}

We now provide a reduction from the problem of solving parametric pushdown parity games to the problem of solving pebble pushdown parity games. Recall the theorem from Section~\ref{pebbles}.


\begin{theorem}\label{PPDA reduction}
{\sc $n$-parametric pushdown parity game} 
is polynomial time reducible to
{\sc $n$-pebble pushdown parity game}.
\end{theorem}




\begin{proof}[Sketch]


Let us fix some
$n$-parametric pushdown automaton $\mathcal{Z}= (Q, \Gamma, 
P, q_{init}, { \gamma_{init}})$,
 disjoint
union $Q = Q_0  \biguplus Q_1$
and $P = P_0 \biguplus P_1$,
and
some priority function 
$\Omega : Q \times \Gamma^* \times ( \Gamma^* \biguplus \{ \bot \})^R \to [0, m ]$.


We construct
  an 
 $n$-pebble pushdown automaton $\ppda =(Q', \Gamma,  R', q_{init}', {\gamma_{init}})$,
a 
 disjoint
union $Q' = Q_0'  \biguplus Q_1'$
and a mapping $\Omega' : Q \times  \Gamma'^* \times ( \Gamma'^* \biguplus \{ \bot \})^{\{1, \ldots, n\}} \to \{1, \ldots, m \}$,
such that
player $0$ has a winning strategy from 
$(q'_{init},\gamma_{init}, \mu_{init})$
in
the parity game
$\mathcal{G'}= (A_{(\ppda, Q'_0, Q'_1)}, \win_{\overline{\Omega'}})$
if and only if
player $0$ has a 
winning strategy from $\mu_\bot$ in 
the parity game
$\mathcal{G} =(A_{(\mathcal{Z}, P_0, P_1, Q_0 , Q_1)}, \win_{\widehat{\Omega}})$,
where		 
$A_{(\mathcal{Z}, P_0, P_1, Q_0 , Q_1)}$
and
$\widehat{\Omega}$
correspond to the definitions on page~\pageref{PPDA reachability game}.




The transition graph of the $n$-pebble pushdown automaton $\ppda$ will simulate the possible transitions graphs 
(one for every 
parameter assignment)
 of the pushdown automaton with $n$ parameters by using pebbles to represent the parameters. 
The $n$-pebble pushdown automaton will first simulate the 
parameter valuation arena.
Players take turns chosing particular stack contents on which to place pebbles. 
Once every parameter has been assigned with the dropping of a corresponding pebble, 
the pebble assignment $\mu$ is fixed.



Further configurations in the $n$-pebble pushdown automaton then consist of a word representing the status of the stack, a state, and a fixed pebble assignment. For a fixed pebble assignment there is then a one for one correspondance between configurations of the $n$-parametric pushdown 
automaton 
and these of the $n$-pebble pushdown automaton. The set of states of the $n$-pebble pushdown automaton apart from the initial gadget is the same as 
the set of states of the $n$-parametric pushdown automaton, and 
so are player $0$ states, player $1$ states and the priority mapping.
\end{proof}

\end{document}

















