

\section{Solving resilience with invariants}

In this section, we study the general resilience problem.

\subsection{Pushdown automata}

%We may consider context-free grammars.

\begin{theorem}
The three {\sc resilience} problems are decidable for pushdown automata with $\Safe$ and $\Bad$ regular languages.
\end{theorem}

\begin{proof}
Recall that resilience is equivalent to  $\Bad \subseteq \pred^*(\Safe)$. For every pushdown automaton $A=(Q,\Sigma,...)$ and every regular language $L \subseteq Q \times \Sigma^*$, the set $\pred^*(L)$ is a computable regular language \cite{DBLP:journals/ipl/BouajjaniEFMRWW00}. Since $\Bad$ and $\Safe$ are both regular, we deduce that
%
%			Moreover, $post^*(\Bad)$ is also a computable regular language \alain{pourquoi ?}   $post^*(L)$ and
 the inclusion $\Bad \subseteq \pred^*(\Safe)$ is decidable and resilience too.
%
The BRP and the kRP are also decidable. The algorithm that computes $ \pred^*(\Safe)$ is polynomial. If $\Bad \subseteq \pred^*(\Safe)$ then one computes an integer $k$ such that the maximum of all minimal pathes that go from $\Bad$ to $\Safe$ is equal to $k$.\alain{à prouver}
%
\end{proof}
%
Let us remark that $\uparrow \post^*(q,w)$ is also a computable regular language, but we cannot directly apply previous results on WSTS since pushdown automata are not WSTS for the usual orderings (subword, prefix).
Context-free grammars are WSTS \cite{DBLP:journals/tcs/FinkelS01} for the subword ordering and $\uparrow \post^*$ is computable but context-free grammars are not strongly compatible.

%  \textcolor{red}{à faire Mathieu}

%
%



\subsection{Regular fifo automata}

Fifo automata and systems of communicating finite-state machines (CFSMs) are essentially finite automata that communicate through fifo channels (or queues). For the sake of simplicity, we consider automata with an unique fifo channel (that have the power of turing machines). In 1986, Pachl introduced in \cite{} the property for such systems to have a regular reachability set (or even a regular relation) and he showed that this gives a semi-algorithm to test non-reachability (with a regular inductive invariant to obtain a witness of non-reachability). Let $(q,w)$ be an initial state and $(q',w')$ be a state. Since $\post^*(q,w)$ is known to be regular (even if we don't know how to compute it), we may enumerate all regular languages $L \subseteq Q \times \Sigma^*$ that contain $(q,w)$ and such that $\post(L) \subseteq L$ (inductive invariant). We know that if $(q',w') \not\in \post^*(q,w)$ then there exists, at least, a regular language $L$ such that $\post^*(q,w) \subseteq L$ and $(q',w') \not\in L$, since $\post^*(q,w)$ is such inductive invariant. This strategy provides a semi-algorithm for non-reachability.
As reachability is recursively enumerable, this provides an algorithm to solve reachability for regular fifo automata.

Let us say that a fifo automaton is \emph{post-regular} (resp. \emph{pred-regular}) if $\post^*(q,w)$ (resp. $\pred^*(q,w)$ ) is regular for all $(q,w) \in Q \times \Sigma^*$. The  fifo automaton is \emph{effectively} post-regular (resp. pred-regular) if the regular language $\post^*(q,w)$ (resp. $\pred^*(q,w)$) is computable. Reachability is (immediately) decidable for both effective post-regular and effective pred-regular fifo automata.
\alain{montrer que post-regular (pred-regular) sur des (q,w) implique post-regular  (pred-regular) sur des langages rationnels L....ça doit marcher en prenant l'expression rationnelle de L...peut-on montrer que pred-regular n'equivaut pas a post-regular ? contre-exemples ? c'est le cas pour les LCM où pred ok mais pas post}
%
%
%Let us say that a fifo automaton is \emph{regular} if the reachability relation is regular for all $(q,w)$; in this case, the fifo automaton is also both post-regular and pred-regular.
%
Now, we just observe that $\Bad \subseteq \pred^*(\Safe)$ is decidable when $\pred^*(\Safe)$ is a computable regular language and $\Bad$ a regular language: 

\begin{theorem}{}
Resilience is decidable for effective pred-regular fifo automata when $\Safe$ and $\Bad$ are regular languages.
\end{theorem} 

%		\begin{proof}
%		$\Bad \subseteq \pred^*(\Safe)$ is decidable because $\pred^*(\Safe)$ is a computable regular language.
%		\alain{prover que $\pred^*(\Safe)$ is a computable regular language}
%		\end{proof}
%
%			Since lossy channel systems have (non computable) regular reachability sets, we imediately deduce that.

Since for  lossy channel systems $\pred^*(L)$ with $L=\uparrow L$ is a computable (upward-closed) regular language, we deduce :

\begin{corollary}
Resilience is decidable for lossy channel systems with $\Safe=\uparrow \Safe$ and any regular language $\Bad$.
\end{corollary}

Another proof is possible for LCS since LCS are WSTS with a computable $\uparrow \post^*(S)$ \alain{à prouver et vérifier les autres hypothèses}
%
%%%
\subsection{LCM, VASS, semilinear VASS, Integer et Continuous VASS}


\begin{theorem}{}
Resilience is decidable for  lossy counter machines, semilinear VASS, Integer VASS when $\Safe$ and $\Bad$ are semilinear sets.
\end{theorem}

\begin{proof}
Resilience is decidable for lossy counter machines with $\Safe$ and $\Bad$ semilinear sets as a consequence of Theorem 3.6 in \cite{DBLP:conf/rp/Schnoebelen10} that implies that $\pred^*(\Safe)$ is a computable semilinear set. Hence since the inclusion between two semilinear sets is decidable, we deduce that  $\Bad \subseteq \pred^*(\Safe)$ is decidable.

%		semilinear VASS.
 \alain{le plus simple serait que $\pred^*(L)$ is semilinear because $\post^*(s)$ is semilinear , peut-être en inversant le VASS V en V'on aurait pred*(V)=post*(V') hence $post^*(L)$ is also semilinear ? hence pred ????}

%		Integer VASS
Recall that reachability is NP-complete for integer VASS. We consider semilinear sets in $\mathbb{Z}^d$.

\end{proof}

We also deduce immediately that resilience is decidable for $2$-VASS that have a semilinear reachability relation.

\begin{theorem}{}
Resilience is decidable for continuous VASS when $\Safe$ and $\Bad$ are definable in the existential theory of
the rationals with addition and order.
\end{theorem}


\begin{proof}
The reachability relation of continuous VASS is definable by a sentence of linear size in the existential theory of
the rationals with addition and order whose complexity is EXPSPACE. Hence, $\Bad \subseteq \pred^*(\Safe)$ is also decidable in EXPSPACE. \alain{and may be in coNP-complete. Recall that reachability is P-complete for continuous VASS}
\end{proof}


open for VASS ???

\section{Computing the largest safe WSTS}

Ici $\Safe$ clos haut. ici on veut rester toujours dans $\Safe$. on calcule les élements minimaux de $\pred^*(\Safe)=\{m_1,m_2,...,m_p\}$ puis on ajoute les préconditions $s' \geq m_1  	\wedge s' \geq m_2  	\wedge...	\wedge s' \geq m_p$ à toutes les transitions $s \rightarrow s'$ assurant que l'état atteint est au dessus des minimaux, ainsi on sera toujours dans $\Safe$. Il faut juste l'hypothèse raisonnable qu'on peut exprimer $s' \geq m_1  	\wedge s' \geq m_2  	\wedge...	\wedge s' \geq m_p$ comme une garde d'une transition (facile dans les VASS et modèles habituels).

\begin{theorem}{}
Given a WSTS and $\Safe$  upward-closed, the largest sub TS, that stays in $\Safe$ , is a computable WSTS.
\end{theorem}

Pour les VASS, je crois qu'on a une borne (2-exp) à la taille de $\pred^*(\Safe)$ et à la taille de ses éléments \cite{DBLP:conf/rp/BozzelliG11} et c'est directement implémentable, donc en particulier, pour tout VASS, il existe un autre VASS de taille 2-exp plus grand qui a le plus grand sous-comportement restant dans $\Safe$ .
Je crois que ça résoud aussi un pb résolu dans Valk et Jantzen 1985 \cite{DBLP:journals/acta/ValkJ85} mais en utilisant le graphe de karp et Miller donc avec complexité ackerman...à bien vérifier que $\pred^*(\Safe)$ n'est pas ackerman...en lisant en détail \cite{DBLP:conf/rp/BozzelliG11}. Dans ce cas, ça permettrait de résoudre autrement les 4 pbs dans \cite{DBLP:journals/acta/ValkJ85} avec une complexité 2-exp plutôt qu'ackerman 

\begin{theorem}{}
Given a VASS and $\Safe$ upward-closed, the largest sub TS, that  stays in $\Safe$, is a computable VASS of size 2-exp.
\end{theorem}

%
\iffalse
%
\subsection{Timed Automata}

\textcolor{red}{Should be defined in a later 'application section' once we start writing any proof, for now I leave it there} 

\renewcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\Const}{\mathsf{Consts}}
\newcommand{\Conf}{\mathsf{Conf}}
\newcommand{\guards}{{\textsc{Guards}}}

% \subsubsection{Guards, Clocks}

A {\em guard} over a finite set of clocks $\Omega$ 
is a comparison of the form
$\omega \bowtie c$, where $ \omega \in \Omega$, $c \in \N$,
and $\bowtie\in\{<,\leq,=,\geq,>\}$.
%
We denote by $\guards(\Omega)$ the {\em set of guards} over the set of 
clocks $\Omega$.
The {\em size} %$|g|$
 of a guard 
$g=\omega \bowtie c$ is defined as %:
$|g|=\log(c)$.
A {\em clock valuation} is a function from $\Omega$ to $\N$;
we write $\vec{0}$ to denote the clock valuation $\omega \mapsto 0$
whenever the set $\Omega$ is clear from the context.
For each clock valuation $v$ and each $t\in\N$ we denote
by $v+t$ the clock valuation $\omega \mapsto v(\omega)+t$.
%
For each guard $g=\omega \bowtie c$ with $c\in\N$,
we write $v\models g$ if $v(\omega)\bowtie c$.

\iffalse
We define an {\em empty guard} $g_\epsilon$ over a non-empty finite set of clocks
$\Omega$ and to be of the form $\omega \geq 0$ for some 
$\omega \in \Omega$. In particular, we
defined $g_\epsilon$ such that for all $v \in \N^\Omega$ 
we have
$v \models g_\epsilon$, hence $g_\epsilon$ can be used as a guard that is always true. 
\fi

% \subsubsection{Timed automata}


A timed automaton is a finite automaton extended with a finite set of clocks $\Omega$ that all progress at the same rate and that can individually be reset to zero. Moreover, every transition is labeled by a guard over 
$\Omega$  and by a set of clocks to be reset. \\

\par\noindent\ignorespacesafterend
Formally, a {\em timed automaton} ({\em TA} for short) is a tuple
$\A=(Q,\Omega,R,q_{init},F)$, where
\begin{samepage}
\begin{itemize}
	\item $Q$ is a non-empty finite {\em set of states}, 
	\item $\Omega$ is a non-empty finite {\em set of clocks},
	\item $R \subseteq Q\times\G(\Omega)\times \mathscr{P}(\Omega) \times Q$
	is a finite {\em set of  rules},
	\item $q_{init}\in Q$ is an {\em initial  state}, and 
	\item $F\subseteq Q$ is a {\em set of final states}.
\end{itemize}
\end{samepage}

\par\noindent\ignorespacesafterend
We also refer to $\A$ as an $n$-TA if $|\Omega| = n$. 
The {\em size} of $\A$ is defined as%:
$$
|\A| \ = \ |Q|+|\Omega|+|R|+\sum_{(q,g,U,q')\in R}|g|.
$$
Let 
$\Const(\A) = \{ c\in\N \mid \exists(q,g,U,q')\in R, \ \exists \omega \in \Omega, \bowtie\in\{<,\leq,=,\geq,>\} : g = \omega \bowtie c \}$ denote the 
set of constants that appear in the guards of the rules of $\A$.

By $\Conf(\A)=Q\times\N^\Omega$ we denote the set of
{\em configurations} of $\A$. 
%We prefer however to denote a configuration in $\Const(\A)$ by $q(v)$ instead of $(q,v)$.\\
We prefer however to abbreviate a configuration	%	 in $\Conf(\A)$	
$(q,v)$ by $q(v)$.


\begin{samepage}
%\begin{definition}
A TA $\A=(Q,\Omega,R,q_{init},F)$ induces the labeled transition system 
$T_{\A} =  (\Conf(\A), \Lambda_{\A}, \rightarrow_{\A})$
where $ \Lambda_{\A} = R \times \N $
and 
where $ \rightarrow_{\A}$ is defined such that, 
for all $(\delta,t)\in R\times\N$ with  	$\delta = (q,g,U,q')\in R$,
for all $q(v), q'(v') \in \Conf(\A)$,
$q(v)\xrightarrow{\delta,t}_{\A} q'(v')$ if
	$v+t\models g$, 
	 $v'(u)=0$ for all $u \in U$ and $v'(\omega)=v(\omega)+t$ for all 
	$\omega \in \Omega \setminus U$.
%\end{definition}
\end{samepage}

A {\em run} from $q_0(v_0)$ to $q_n(v_n)$ in $\A$ is a path in the transition system $T_{\A}$, that is,
a sequence 
$\pi = q_0(v_0)\xrightarrow{\delta_1,t_1}_{\A}q_1(v_1)\cdots\xrightarrow{\delta_n,t_n}_{\A}q_n(v_n)$;
it is called {\em reset-free} if for all $i \in \{1,\ldots,n\}$,
 $\delta_i = (g_i,\emptyset)$ for some guard $g_i$.


We say $\pi$ is {\em accepting} if $q_0(v_0) = q_{init}(\vec{0})$ and $q_n \in F$. 
\iffalse
We say {\em reachability holds} for the TA $\A$ 
if there exists an accepting run. %
% if there is a run in $\A$ from $q_{init}(\vec{0})$   to some configuration $q(v)$ for some $q\in F$, and $v\in\N^\Omega$.
%We refer to Figure~\ref{example pta} for an instance of a PTA for which reachability holds.
\fi


It is worth mentioning that there are further modes of time valuations and guards which exist in the literature, we refer
to \cite{Andre19} for a recent overview. 
%
% \mh{Comment on difference between continuous and discrete time}
Notably, we consider in this article only the case of timed automata over discrete time. It is worth mentioning that in
the case of timed automata over continuous time (i.e. with clocks having values in $\R_{\geq 0}$),
% However, for parametric timed automata with closed (i.e., non-strict) clock constraints and parameters restricted to ranging over integers, 1 standard digitisation techniques apply [HMP92, OW03], reducing the reachability problem over dense time to discrete (integer) time.
techniques~\cite{HenzingerMP92,OuaknineW03} exist for reducing the reachability problem to discrete time in the case of closed (i.e. non-strict) clock constraints ranging over integers. \\




\problemx{TA $k$-resilience problem}
{A state $q$ of a TA $(Q, X, \Delta)$, a set $SAFE \subseteq Q$, a set $BAD \subseteq Q$.}
{$\forall q' \in BAD \forall v,v' \in \N^X ~ (q(v) \rightarrow^* q'(v')) \implies \exists q'' \in SAFE \exists v'' \in \N^X ~ q'(v') \rightarrow^{\leq k} q''(v'')$ ?\newline}


Analogously, we formulate the bounded resilience problem for WSTSs.


\problemx{TA bounded resilience problem}
{A state $q$ of a TA $(Q, X, \Delta)$, a set $SAFE \subseteq Q$, a set $BAD \subseteq Q$.}
{$\exists k \geq 0 ~ \forall q' \in BAD \forall v,v' \in \N^X ~ (q(v) \rightarrow^* q'(v')) \implies \exists q'' \in SAFE \exists v'' \in \N^X ~ q'(v') \rightarrow^{\leq k} q''(v'')$ ?\newline}

\textcolor{red}{I think there can be a discussion to be had here about how to quantify on the clock valuations}

\textcolor{red}{Here one thing that could be interesting to try to formalize is: how to enforce that the time that passes is less than $k$, rather than the number of transitions. This is tricky to deal with I find but it should be more doable if for instance we use one counter automata, where the counter effect of the sequence can be quantified more explicitly I suppose ?
But here you could also use a kinda special clock $x$ that is reset when you enter $BAD$ and is not reset between a state in $BAD$ and a state in $SAFE$, you could check that $x < k$.}

\textcolor{red}{... I guess if you use $0/1$-TA then the problems become closer one to another ? Also of note is that $0/1$-TA induces transition systems with bounded branching, so I guess it may be interesting to investigate these first ?}

A {\em $0/1$ timed automaton } ({\em $0/1$-TA} for short) is a tuple
$$\B=(Q,X, \Delta_0, \Delta_1, q_{init}, F),$$
\par\noindent\ignorespacesafterend
 where
$\B_i=(Q,X, R_i, q_{init}, F)$ is a TA for all $i \in \{0,1\}$.
For simplicity we define its {\em size}
as $|\B|=|\B_0|+|\B_1|$.
We analogously denote the constants of $\B$ 
by $\Const(\B)$ and its configurations by  $\Conf(\B)$.

\begin{samepage}
%\begin{definition}
A $0/1$ timed automaton $\B=(Q,X,R_0,R_1,q_{init},F)$ 
induces the labeled transition system 
$T_{\B} = (\Conf(\B), \lambda_{\B}, \rightarrow_{\B}) $
where $ \lambda_{\B} = (R_0 \cup R_1) \times \{ 0,1\}$
	and where $ \rightarrow_{\B}$
	is defined such that
	for all $q(z), q'(z') \in \Conf(\B)$, 
	for all $(\delta,i) \in \lambda_{\B}$
	with $\delta  = (q,g,U,q')\in R_i$
	$q(v)\xrightarrow{\delta,i}_{\B} q'(v')$ if
	$v+i \models g$, 
	$v'(u)=0$ for all $u \in U$ and $v'(\omega)=v(\omega)+ i$ for all $\omega \in \Omega
	\setminus U$. 
%\end{definition}
\end{samepage}



As expected, we write $q(v)\xrightarrow{\delta,i}_{\B}q'(v')$ if 
$q(v)\xrightarrow{\delta,i}_{\B}q'(v')$ for some 
$i\in\{0,1\}$, and some $\delta \in R_i$.




\subsection{One-Counter Automata}

\textcolor{red}{Should be defined in a later 'application section' once we start writing any proof, for now I leave it there} 


\problemx{OCA $k$-resilience problem}
{A state $q$ of a OCA $(Q, \Delta)$, a set $SAFE \subseteq Q$, a set $BAD \subseteq Q$.}
{$\forall q' \in BAD \forall n,n' \in \N ~ (q(n) \rightarrow^* q'(n')) \implies \exists q'' \in SAFE \exists n'' \in \N ~ q'(n') \rightarrow^{\leq k} q''(n'')$ ?\newline}



\problemx{OCA bounded resilience problem}
{A state $q$ of a OCA $(Q, \Delta)$, a set $SAFE \subseteq Q$, a set $BAD \subseteq Q$.}
{$\exists k \geq 0 ~ \forall q' \in BAD \forall n,n' \in \N ~ (q(n) \rightarrow^* q'(n')) \implies \exists q'' \in SAFE \exists n'' \in \N ~ q'(n') \rightarrow^{\leq k} q''(n'')$ ?\newline}

%
\fi
%

\section{conclusion}


\alain{trouver les \Bad~ et \Safe~ maximum tels que S est resilient. est-ce vrai que si S est $(B_i,D_i)$-resilient alors S est $(\cap, \cup B_i,D_i)$-resilient ?}
%
\alain{on peut penser à des ensembles $\Bad$ definis dans une logique booleennne sur les clos par le bas, haut, +...}


%
%
%\subsection{Vector Addition System with States or PN}
%
%\textcolor{red}{Should be defined in a later 'application section' once we start writing any proof, for now I leave it there} 
%



